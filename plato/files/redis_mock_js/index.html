<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>redis-mock.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">72.31</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">649</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">162.28</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">7.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/* jshint unused:true, undef:true, strict:true, plusplus:true */
/* global setTimeout:false, module:false, exports:true, clearTimeout:false, console:false */

(function () {

    &quot;use strict&quot;;

    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Create a safe reference to the mock object for use below.
    var redismock = {};

    // Export the mock object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we&#039;re in
    // the browser, add `redismock` as a global object.
    if (typeof exports !== &#039;undefined&#039;) {
        if (typeof module !== &#039;undefined&#039; &amp;&amp; module.exports) {
            exports = module.exports = redismock;
        }
        exports.redismock = redismock;
    } 
    else {
        root.redismock = redismock;
    }

    if (typeof setImmediate === &#039;undefined&#039;) {
        var setImmediate = function (f) {
            setTimeout(f, 0);
        };
    }

    var cache = {};
    var timeouts = {};
    var mySubscriptions = {};
    //var watchers = {};
    var sets = &#039;sets-&#039; + Math.random();
    var zsets = &#039;zsets-&#039; + Math.random();
    var hashes = &#039;hashes-&#039; + Math.random();
    cache[sets] = {};
    cache[zsets] = {};
    cache[hashes] = {};

    var cb = function (callback, context) {
        return function () {
            var args = arguments;
            if (callback &amp;&amp; typeof callback === &quot;function&quot;) {
                setImmediate(function () {
                    callback.apply(context, args);
                });
            }
            if (args[0] instanceof Error) {
                return args[0];
            }
            return args[1];
        };
    };

    var gather = function (f) {
        var end = f.length;
        return function () {
            var idx, len = arguments.length;
            var callback;
            var list = [arguments[end - 2]];
            if (len &gt;= end) {
                for (idx = end - 1; idx &lt; len; idx += 1) {
                    if (typeof arguments[idx] === &quot;function&quot;) {
                        callback = arguments[idx];
                    }
                    else if (arguments[idx]) {
                        list.push(arguments[idx]);
                    }
                }
            }
            return {
                callback: callback,
                list: list
            };
        };
    };

    var wrongType = function (callback) {
        return cb(callback)(new Error(&#039;WRONGTYPE&#039;));
    };

    redismock.ifType = function (key, type, callback) {
        var that = this;
        return {
            thenex: function (f) {
                this._ifex = f;
                return this;
            },
            thennx: function (f) {
                this._ifnx = f;
                return this;
            },
            then: function (f) {
                this._then = f;
                return this;
            },
            end: function () {
                var ret;
                if (that.exists(key)) {
                    if (that.type(key) !== type) {
                        return wrongType(callback);
                    }
                    if (typeof this._ifex === &#039;function&#039;) {
                        ret = this._ifex.call(that);
                    }
                }
                else {
                    if (typeof this._ifnx === &#039;function&#039;) {
                        ret = this._ifnx.call(that);
                    }
                }
                if (typeof this._then === &#039;function&#039;) {
                    ret = this._then.call(that);
                }
                return ret;
            }
        };
    };

    redismock.set = function (key, value, callback) {
        var nx = false, xx = false, ex = -1, px = -1;
        var g = gather(this.set).apply(this, arguments);
        callback = g.callback;
        g.list.forEach(function (opt, index) {
            if (opt === &#039;nx&#039;) {
                nx = true;
            }
            else if (opt === &#039;xx&#039;) {
                xx = true;
            }
            else if (opt === &#039;ex&#039;) {
                ex = g.list[index + 1];
            }
            else if (opt === &#039;px&#039;) {
                px = g.list[index + 1];
            }
        });
        if (nx) {
            if (this.exists(key)) {
                return cb(callback)(null, null);
            }
        }
        if (xx) {
            if (!this.exists(key)) {
                return cb(callback)(null, null);
            }
        }
        cache[key] = value.toString();
        if (px !== -1) {
            redismock.pexpire(key, px);
        }
        if (ex !== -1) {
            redismock.expire(key, ex);
        }
        return cb(callback)(null, &#039;OK&#039;);
    };

    redismock.get = function (key, callback) {
        if (this.type(key) === &#039;string&#039;) {
            return cb(callback)(null, cache[key]);
        }
        return cb(callback)(null, null);
    };

    redismock.getset = function (key, value, callback) {
        var prev = this.get(key);
        this.set(key, value);
        return cb(callback)(null, prev);
    };

    redismock.expire = function (key, seconds, callback) {
        return this.pexpire(key, seconds*1000, callback);
    };

    redismock.pexpire = function (key, milliseconds, callback) {
        if (this.exists(key)) {
            if (key in timeouts) {
                clearTimeout(timeouts[key]);
            }
            timeouts[key] = setTimeout(function () {
                if (key in cache) {
                    delete cache[key];
                }
                else if (key in cache[sets]) {
                    delete cache[sets][key];
                }
                else if (key in cache[zsets]) {
                    delete cache[zsets][key];
                }
                else if (key in cache[hashes]) {
                    delete cache[hashes][key];
                }
            }, milliseconds);
            return cb(callback)(null, 1);
        }
        return cb(callback)(null, 0);
    };

    redismock.psetex = function (key, milliseconds, value, callback) {
        this.set(key, value);
        this.pexpire(key, milliseconds);
        return cb(callback)(null, &#039;OK&#039;);
    };

    redismock.setex = function (key, seconds, value, callback) {
        this.set(key, value);
        this.expire(key, seconds);
        return cb(callback)(null, &#039;OK&#039;);
    };

    redismock.setnx = function (key, value, callback) {
        if (!this.exists(key)) {
            this.set(key, value);
            return cb(callback)(null, 1);
        }
        return cb(callback)(null, 0);
    };

    redismock.strlen = function (key, callback) {
        if (!this.exists(key)) {
            return cb(callback)(null, 0);
        }
        return this
            .ifType(key, &#039;string&#039;, callback)
            .thenex(function () { return cb(callback)(null, cache[key].length); })
            .thennx(function () { return cb(callback)(null, 0); })
            .end();
    };

    redismock.exists = function (key, callback) {
        return cb(callback)(null, key in cache || key in cache[sets] || key in cache[zsets] || key in cache[hashes] ? 1 : 0);
    };

    redismock.del = function (key, callback) {
        var that = this;
        var count = 0;
        var g = gather(this.del).apply(this, arguments);
        callback = g.callback;
        g.list.forEach(function (key) {
            if (that.exists(key)) {
                if (key in cache) {
                    delete cache[key];
                }
                else if (key in cache[sets]) {
                    delete cache[sets][key];
                }
                else if (key in cache[zsets]) {
                    delete cache[zsets][key];
                }
                else if (key in cache[hashes]) {
                    delete cache[hashes][key];
                }
                count += 1;
            }
        });
        return cb(callback)(null, count);
    };

    redismock.lpush = function (key, element, callback) {
        var g = gather(this.lpush).apply(this, arguments);
        callback = g.callback;
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thennx(function () { cache[key] = []; })
            .then(function () {
                cache[key] = g.list.concat(cache[key]);
                return cb(callback)(null, cache[key].length);
            })
            .end();
    };

    redismock.rpush = function (key, element, callback) {
        var g = gather(this.rpush).apply(this, arguments);
        callback = g.callback;
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thennx(function () { cache[key] = []; })
            .then(function () {
                cache[key] = cache[key].concat(g.list);
                return cb(callback)(null, cache[key].length);
            })
            .end();
    };

    redismock.lpop = function (key, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () { return cb(callback)(null, cache[key].shift()); })
            .thennx(function () { return cb(callback)(null, null); })
            .end();
    };

    redismock.rpop = function (key, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () { return cb(callback)(null, cache[key].pop()); })
            .thennx(function () { return cb(callback)(null, null); })
            .end();
    };

    redismock.lindex = function (key, i, callback) {
        var elem = null;
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () {
                if (i &gt;= 0 &amp;&amp; i &lt; cache[key].length) {
                    elem = cache[key][i];
                }
                else if (i &lt; 0 &amp;&amp; cache[key].length + 1 &gt;= 0) {
                    elem = cache[key][cache[key].length + i];
                }
            })
            .then(function () { return cb(callback)(null, elem); })
            .end();
    };

    redismock.ltrim = function (key, start, end, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () {
                var tmpS, tmpE;
                if (start &gt; cache[key].length - 1 || start &gt; end) {
                    delete cache[key];
                }
                else {
                    if (start &lt; 0 &amp;&amp; end &lt; 0) {
                        tmpE = cache[key].length + end;
                        tmpS = cache[key].length + start;
                        if (tmpS &lt; 0) {
                            tmpS = 0;
                        }
                        start = tmpS;
                        end = tmpE;
                    }
                    if (end &gt; cache[key].length - 1) {
                        end = cache[key].length - 1;
                    }
                    cache[key] = cache[key].slice(start, end + 1);
                }
            })
            .then(function () { return cb(callback)(null, &#039;OK&#039;); })
            .end();
    };

    redismock.lrange = function (key, start, end, callback) {
        var l = [];
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () {
                var tmpS, tmpE;
                if (start &gt; cache[key].length - 1) {
                    l = [];
                }
                else {
                    if (start &lt; 0 &amp;&amp; end &lt; 0) {
                        tmpS = cache[key].length + end;
                        tmpE = cache[key].length + start;
                        start = tmpS;
                        end = tmpE;
                    }
                    if (start &gt;= 0 &amp;&amp; end &lt; 0) {
                        end = cache[key].length + end;
                    }
                    if (end &gt; cache[key].length - 1) {
                        end = cache[key].length - 1;
                    }
                    l = cache[key].slice(start, end + 1);
                }
            })
            .then(function () { return cb(callback)(null, l); })
            .end();
    };

    redismock.linsert = function (key, beforeafter, pivot, value, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () {
                var idx = cache[key].indexOf(pivot);
                if (idx !== -1) {
                    if (beforeafter === &#039;before&#039;) {
                        cache[key].splice(idx, 0, value);
                    }
                    else if (beforeafter === &#039;after&#039;) {
                        cache[key].splice(idx + 1, 0, value);
                    }
                    return cb(callback)(null, cache[key].length);
                }
                return cb(callback)(null, -1);
            })
            .thennx(function () { return cb(callback)(null, 0); })
            .end();
    };

    redismock.llen = function (key, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () { return cb(callback)(null, cache[key].length); })
            .thennx(function () { return cb(callback)(null, 0); })
            .end();
    };

    redismock.rpoplpush = function (source, dest, callback) {
        var element = this.rpop(source);
        this.lpush(dest, element);
        return cb(callback)(null, element);
    };

    redismock.lrem = function (key, count, element, callback) {
        var cnt = 0;
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () {
                var idx;
                while (true) {
                    idx = cache[key].indexOf(element);
                    if (idx === -1) {
                        break;
                    }
                    cache[key].splice(idx, 1);
                    cnt += 1;
                    if (count &gt; 0 &amp;&amp; cnt === count) {
                        break;
                    }
                }
            })
            .then(function () { return cb(callback)(null, cnt); })
            .end();
    };

    redismock.lset = function (key, index, element, callback) {
        return this
            .ifType(key, &#039;list&#039;, callback)
            .thenex(function () { 
                if (index &gt;= cache[key].length) {
                    return cb(callback)(new Error(&#039;ERR index out of range&#039;));
                }
                cache[key][index] = element;
                return cb(callback)(null, &#039;OK&#039;);
            })
            .thennx(function () { return cb(callback)(new Error(&#039;ERR no such key&#039;)); })
            .end();
    };

    redismock.sadd = function (key, member, callback) {
        var g = gather(this.sadd).apply(this, arguments);
        callback = g.callback;
        return this
            .ifType(key, &#039;set&#039;, callback)
            .thennx(function () { cache[sets][key] = {}; })
            .then(function () {
                g.list.forEach(function (m) {
                    cache[sets][key][m.toString()] = m;
                });
                return cb(callback)(null, 1);
            })
            .end();
    };

    redismock.srandmember = function (key, callback) {
        return this
            .ifType(key, &#039;set&#039;, callback)
            .thenex(function () {
                var k = Object.keys(cache[sets][key]);
                return cb(callback)(null, cache[sets][key][k[Math.floor(Math.random() * k.length)]]);
            })
            .thennx(function () { return cb(callback)(null, null); })
            .end();
    };

    redismock.srem = function (key, member, callback) {
        var g = gather(this.srem).apply(this, arguments);
        var count = 0;
        callback = g.callback;
        return this
            .ifType(key, &#039;set&#039;, callback)
            .thenex(function () {
                g.list.forEach(function (m) {
                    var k = m.toString();
                    if (k in cache[sets][key]) {
                        delete cache[sets][key][k];
                    }
                    count += 1;
                });
                return cb(callback)(null, 1);
            })
            .then(function () { return cb(callback)(null, count); })
            .end();
    };

    redismock.smove = function (source, dest, member, callback) {
        var r = redismock.srem(source, member);
        redismock.sadd(dest, member);
        return cb(callback)(null, r);
    };

    redismock.zadd = function (key, score, member, callback) {
        var g = gather(this.zadd).apply(this, arguments);
        callback = g.callback;
        return this
            .ifType(key, &#039;zset&#039;, callback)
            .thennx(function () { cache[zsets][key] = {}; })
            .then(function () {
                g
                    .list
                    .map(function (elem, index) {
                        if (index % 2 === 0) {
                            return [g.list[index], g.list[index + 1]];
                        }
                        return null;
                    })
                    .filter(function (elem) {
                        return elem !== null;
                    })
                    .forEach(function (sm) {
                        var score = sm[0];
                        var m = sm[1];
                        if (!(score in cache[zsets][key])) {
                            cache[zsets][key][score] = [];
                        }
                        cache[zsets][key][score].push(m);
                    });
                return cb(callback)(null, 1);
            })
            .end();
    };

    /*redismock.zrangebyscore = function (key, min, max, callback) {
    };*/

    redismock.hdel = function (key, field, callback) {
        var count = 0;
        var g = gather(this.hdel).apply(this, arguments);
        callback = g.callback;
        return this
            .ifType(key, &#039;hash&#039;, callback)
            .thenex(function () {
                g.list.forEach(function (field) {
                    if (field in cache[hashes][key]) {
                        delete cache[hashes][key][field];
                        count += 1;
                    }
                });
            })
            .then(function () { return cb(callback)(null, count); })
            .end();
    };
    
    redismock.hexists = function (key, field,  callback) {
        return this
            .ifType(key, &#039;hash&#039;, callback)
            .thenex(function () { return cb(callback)(null, field in cache[hashes][key] ? 1 : 0); })
            .thennx(function () { return cb(callback)(null, 0); })
            .end();
    };

    redismock.hget = function (key, field, callback) {
        return this
            .ifType(key, &#039;hash&#039;, callback)
            .thenex(function () { return cb(callback)(null, cache[hashes][key][field]); })
            .thennx(function () { return cb(callback)(null, null); })
            .end();
    };

    redismock.subscribe = function (channel, callback) {
        var idx, len = arguments.length;
        var channels = [channel];
        if (len &gt;= 2) {
            for (idx = 1; idx &lt; len; idx += 1) {
                if (typeof arguments[idx] === &quot;function&quot;) {
                    callback = arguments[idx];
                }
                else if (arguments[idx]) {
                    channels.push(arguments[idx]);
                }
            }
        }
        channels.forEach(function (channel) {
            if (!(channel in mySubscriptions)) {
                mySubscriptions[channel] = [];
            }
            mySubscriptions[channel].push(callback);
        });
    };

    redismock.unsubscribe = function (channel) {
        var idx, len = arguments.length;
        var channels = [channel];
        if (!channel) {
            mySubscriptions = {};
        }
        else if (len &gt;= 2) {
            for (idx = 1; idx &lt; len; idx += 1) {
                if (arguments[idx]) {
                    channels.push(arguments[idx]);
                }
            }
            channels.forEach(function (channel) {
                if (channel in mySubscriptions) {
                    delete mySubscriptions[channel];
                }
            });
        }
    };

    redismock.publish = function (channel, message) {
        if (channel in mySubscriptions) {
            mySubscriptions[channel].forEach(function (callback) {
                cb(callback)(channel, message);
            });
        }
    };

    redismock.type = function (key, callback) {
        if (this.exists(key)) {
            var type = typeof cache[key];
            if (type === &#039;object&#039;) {
                if (cache[key] instanceof Array) {
                    type = &#039;list&#039;;
                }
                else {
                    if (key in cache[sets]) {
                        type = &#039;set&#039;;
                    }
                    else if (key in cache[zsets]) {
                        type = &#039;zset&#039;;
                    }
                    else if (key in cache[hashes]) {
                        type = &#039;hash&#039;;
                    }
                }
            }
            return cb(callback)(null, type);
        }
        return cb(callback)(null, &#039;none&#039;);
    };

    redismock.info = function (callback) {
        // TODO
        return cb(callback)(null, &#039;&#039;);
    };
    
    redismock.debug = function (logger) {
        if (!logger) {
            logger = console;
        }
        logger.log(cache);
    };
}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
